/*
 * Copyright Â© 2019 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package co.cask.gcp.datastore.sink;

import co.cask.cdap.api.data.format.StructuredRecord;
import co.cask.cdap.api.data.schema.Schema;
import co.cask.gcp.datastore.sink.util.IndexStrategy;
import co.cask.gcp.datastore.sink.util.SinkKeyType;
import com.google.cloud.Timestamp;
import com.google.cloud.datastore.FullEntity;
import com.google.cloud.datastore.IncompleteKey;
import com.google.cloud.datastore.Key;
import com.google.cloud.datastore.KeyFactory;
import com.google.cloud.datastore.PathElement;
import org.junit.Assert;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import java.time.ZonedDateTime;
import java.util.Collections;

/**
 * Tests for {@link DatastoreSink} class.
 */
@RunWith(MockitoJUnitRunner.class)
public class DatastoreSinkTransformerTest {

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @InjectMocks
  private DatastoreSinkTransformer transformer;

  @Mock
  private DatastoreSinkConfig config;

  @SuppressWarnings("ConstantConditions")
  @Test
  public void testTransformAllTypesIndexStrategyAll() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);
    Mockito.when(config.getAncestor()).thenReturn(Collections.emptyList());
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.AUTO_GENERATED_KEY);

    Schema schema = Schema.recordOf("schema",
      Schema.Field.of("string_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("long_field", Schema.nullableOf(Schema.of(Schema.Type.LONG))),
      Schema.Field.of("int_field", Schema.nullableOf(Schema.of(Schema.Type.INT))),
      Schema.Field.of("double_field", Schema.nullableOf(Schema.of(Schema.Type.DOUBLE))),
      Schema.Field.of("float_field", Schema.nullableOf(Schema.of(Schema.Type.FLOAT))),
      Schema.Field.of("boolean_field", Schema.nullableOf(Schema.of(Schema.Type.BOOLEAN))),
      Schema.Field.of("timestamp_field", Schema.nullableOf(Schema.of(Schema.LogicalType.TIMESTAMP_MICROS))),
      Schema.Field.of("blob_field", Schema.nullableOf(Schema.of(Schema.Type.BYTES))),
      Schema.Field.of("null_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("entity_field",
                      Schema.nullableOf(Schema.recordOf("entity_field",
                        Schema.Field.of("nested_string_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
                        Schema.Field.of("nested_long_field", Schema.nullableOf(Schema.of(Schema.Type.LONG)))
      )))
    );

    ZonedDateTime dateTime = ZonedDateTime.now();

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("long_field", 10L)
      .set("int_field", 15)
      .set("double_field", 10.5D)
      .set("float_field", 15.5F)
      .set("boolean_field", true)
      .setTimestamp("timestamp_field", dateTime)
      .set("blob_field", "test_blob".getBytes())
      .set("null_field", null)
      .set("entity_field", StructuredRecord.builder(schema.getField("entity_field").getSchema().getNonNullable())
        .set("nested_string_field", "nested_value")
        .set("nested_long_field", 20L)
        .build())
      .build();

    FullEntity<?> outputEntity = transformer.transformStructuredRecord(inputRecord);

    Assert.assertEquals("string_value", outputEntity.getString("string_field"));
    Assert.assertFalse(outputEntity.getValue("string_field").excludeFromIndexes());

    Assert.assertEquals(10L, outputEntity.getLong("long_field"));
    Assert.assertFalse(outputEntity.getValue("long_field").excludeFromIndexes());

    Assert.assertEquals(15, outputEntity.getLong("int_field"));
    Assert.assertFalse(outputEntity.getValue("int_field").excludeFromIndexes());

    Assert.assertEquals(10.5D, outputEntity.getDouble("double_field"), 0);
    Assert.assertFalse(outputEntity.getValue("double_field").excludeFromIndexes());

    Assert.assertEquals(15.5, outputEntity.getDouble("float_field"), 0);
    Assert.assertFalse(outputEntity.getValue("float_field").excludeFromIndexes());

    Assert.assertEquals(Timestamp.ofTimeSecondsAndNanos(dateTime.toEpochSecond(), dateTime.getNano()),
                        outputEntity.getTimestamp("timestamp_field"));
    Assert.assertFalse(outputEntity.getValue("timestamp_field").excludeFromIndexes());

    Assert.assertTrue(outputEntity.getBoolean("boolean_field"));
    Assert.assertFalse(outputEntity.getValue("boolean_field").excludeFromIndexes());

    Assert.assertEquals("test_blob", new String(outputEntity.getBlob("blob_field").toByteArray()));
    Assert.assertFalse(outputEntity.getValue("blob_field").excludeFromIndexes());

    Assert.assertNull(outputEntity.getString("null_field"));
    Assert.assertFalse(outputEntity.getValue("null_field").excludeFromIndexes());

    FullEntity<IncompleteKey> nestedEntity = outputEntity.getEntity("entity_field");
    Assert.assertFalse(outputEntity.getValue("entity_field").excludeFromIndexes());

    Assert.assertEquals("nested_value", nestedEntity.getString("nested_string_field"));
    Assert.assertFalse(nestedEntity.getValue("nested_string_field").excludeFromIndexes());

    Assert.assertEquals(20L, nestedEntity.getLong("nested_long_field"));
    Assert.assertFalse(nestedEntity.getValue("nested_long_field").excludeFromIndexes());
  }

  @SuppressWarnings("ConstantConditions")
  @Test
  public void testTransformAllTypesIndexStrategyNone() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.NONE);
    Mockito.when(config.getAncestor()).thenReturn(Collections.emptyList());
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.AUTO_GENERATED_KEY);

    Schema schema = Schema.recordOf("schema",
      Schema.Field.of("string_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("long_field", Schema.nullableOf(Schema.of(Schema.Type.LONG))),
      Schema.Field.of("int_field", Schema.nullableOf(Schema.of(Schema.Type.INT))),
      Schema.Field.of("double_field", Schema.nullableOf(Schema.of(Schema.Type.DOUBLE))),
      Schema.Field.of("float_field", Schema.nullableOf(Schema.of(Schema.Type.FLOAT))),
      Schema.Field.of("boolean_field", Schema.nullableOf(Schema.of(Schema.Type.BOOLEAN))),
      Schema.Field.of("timestamp_field", Schema.nullableOf(Schema.of(Schema.LogicalType.TIMESTAMP_MICROS))),
      Schema.Field.of("blob_field", Schema.nullableOf(Schema.of(Schema.Type.BYTES))),
      Schema.Field.of("null_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("entity_field",
                      Schema.nullableOf(Schema.recordOf("entity_field",
                        Schema.Field.of("nested_string_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
                        Schema.Field.of("nested_long_field", Schema.nullableOf(Schema.of(Schema.Type.LONG)))))));

    ZonedDateTime dateTime = ZonedDateTime.now();

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("long_field", 10L)
      .set("int_field", 15)
      .set("double_field", 10.5D)
      .set("float_field", 15.5F)
      .set("boolean_field", true)
      .setTimestamp("timestamp_field", dateTime)
      .set("blob_field", "test_blob".getBytes())
      .set("null_field", null)
      .set("entity_field", StructuredRecord.builder(schema.getField("entity_field").getSchema().getNonNullable())
        .set("nested_string_field", "nested_value")
        .set("nested_long_field", 20L)
        .build())
      .build();

    FullEntity<?> outputEntity = transformer.transformStructuredRecord(inputRecord);

    Assert.assertEquals("string_value", outputEntity.getString("string_field"));
    Assert.assertTrue(outputEntity.getValue("string_field").excludeFromIndexes());

    Assert.assertEquals(10L, outputEntity.getLong("long_field"));
    Assert.assertTrue(outputEntity.getValue("long_field").excludeFromIndexes());

    Assert.assertEquals(15, outputEntity.getLong("int_field"));
    Assert.assertTrue(outputEntity.getValue("int_field").excludeFromIndexes());

    Assert.assertEquals(10.5D, outputEntity.getDouble("double_field"), 0);
    Assert.assertTrue(outputEntity.getValue("double_field").excludeFromIndexes());

    Assert.assertEquals(15.5, outputEntity.getDouble("float_field"), 0);
    Assert.assertTrue(outputEntity.getValue("float_field").excludeFromIndexes());

    Assert.assertEquals(Timestamp.ofTimeSecondsAndNanos(dateTime.toEpochSecond(), dateTime.getNano()),
                        outputEntity.getTimestamp("timestamp_field"));
    Assert.assertTrue(outputEntity.getValue("timestamp_field").excludeFromIndexes());

    Assert.assertTrue(outputEntity.getBoolean("boolean_field"));
    Assert.assertTrue(outputEntity.getValue("boolean_field").excludeFromIndexes());

    Assert.assertEquals("test_blob", new String(outputEntity.getBlob("blob_field").toByteArray()));
    Assert.assertTrue(outputEntity.getValue("blob_field").excludeFromIndexes());

    Assert.assertNull(outputEntity.getString("null_field"));
    Assert.assertTrue(outputEntity.getValue("null_field").excludeFromIndexes());

    FullEntity<IncompleteKey> nestedEntity = outputEntity.getEntity("entity_field");
    Assert.assertTrue(outputEntity.getValue("entity_field").excludeFromIndexes());

    Assert.assertEquals("nested_value", nestedEntity.getString("nested_string_field"));
    Assert.assertTrue(nestedEntity.getValue("nested_string_field").excludeFromIndexes());

    Assert.assertEquals(20L, nestedEntity.getLong("nested_long_field"));
    Assert.assertTrue(nestedEntity.getValue("nested_long_field").excludeFromIndexes());
  }

  @Test
  public void testTransformIndexStrategyCustom() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.CUSTOM);
    Mockito.when(config.getIndexedProperties()).thenReturn(Collections.singleton("string_field"));
    Mockito.when(config.getAncestor()).thenReturn(Collections.emptyList());
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.AUTO_GENERATED_KEY);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("long_field", Schema.of(Schema.Type.LONG)));

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("long_field", 200L)
      .build();

    FullEntity<?> outputEntity = transformer.transformStructuredRecord(inputRecord);

    Assert.assertEquals("string_value", outputEntity.getString("string_field"));
    Assert.assertFalse(outputEntity.getValue("string_field").excludeFromIndexes());

    Assert.assertEquals(200L, outputEntity.getLong("long_field"));
    Assert.assertTrue(outputEntity.getValue("long_field").excludeFromIndexes());
  }

  @Test
  public void testTransformWithCustomStringKey() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getAncestor()).thenReturn(Collections.emptyList());
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.CUSTOM_NAME);
    Mockito.when(config.getKeyAlias()).thenReturn("test_key_alias");
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.STRING)));

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", "custom_string_key_value")
      .build();

    FullEntity<?> outputEntity = transformer.transformStructuredRecord(inputRecord);

    Assert.assertEquals("string_value", outputEntity.getString("string_field"));

    Key expectedKey = Key.newBuilder(DatastoreSinkConfigHelper.TEST_PROJECT,
                                     DatastoreSinkConfigHelper.TEST_KIND,
                                     "custom_string_key_value")
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .build();
    Assert.assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformWithCustomLongKey() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getAncestor()).thenReturn(Collections.emptyList());
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.CUSTOM_NAME);
    Mockito.when(config.getKeyAlias()).thenReturn("test_key_alias");
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.LONG)));

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", 380L)
      .build();

    FullEntity<?> outputEntity = transformer.transformStructuredRecord(inputRecord);

    Assert.assertEquals("string_value", outputEntity.getString("string_field"));

    Key expectedKey = Key.newBuilder(DatastoreSinkConfigHelper.TEST_PROJECT,
                                     DatastoreSinkConfigHelper.TEST_KIND,
                                     380L)
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .build();
    Assert.assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformWithCustomLongKeyWithAncestor() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getAncestor()).thenReturn(Collections.singletonList(PathElement.of("A", 100)));
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.CUSTOM_NAME);
    Mockito.when(config.getKeyAlias()).thenReturn("test_key_alias");
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.LONG)));

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", 380L)
      .build();

    FullEntity<?> outputEntity = transformer.transformStructuredRecord(inputRecord);

    Assert.assertEquals("string_value", outputEntity.getString("string_field"));

    Key expectedKey = new KeyFactory(DatastoreSinkConfigHelper.TEST_PROJECT)
      .setKind(DatastoreSinkConfigHelper.TEST_KIND)
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .addAncestor(PathElement.of("A", 100))
      .newKey(380L);
    Assert.assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformWithKeyLiteral() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.KEY_LITERAL);
    Mockito.when(config.getKeyAlias()).thenReturn("test_key_alias");
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.STRING)));

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", String.format("key(A, 100, %s, 'test_string_id')", DatastoreSinkConfigHelper.TEST_KIND))
      .build();

    FullEntity<?> outputEntity = transformer.transformStructuredRecord(inputRecord);

    Assert.assertEquals("string_value", outputEntity.getString("string_field"));

    Key expectedKey = new KeyFactory(DatastoreSinkConfigHelper.TEST_PROJECT)
      .setKind(DatastoreSinkConfigHelper.TEST_KIND)
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .addAncestor(PathElement.of("A", 100))
      .newKey("test_string_id");
    Assert.assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformWithUrlSafeKey() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.URL_SAFE_KEY);
    Mockito.when(config.getKeyAlias()).thenReturn("test_key_alias");
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.STRING)));

    Key expectedKey = new KeyFactory(DatastoreSinkConfigHelper.TEST_PROJECT)
      .setKind(DatastoreSinkConfigHelper.TEST_KIND)
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .addAncestor(PathElement.of("A", 100))
      .newKey("test_string_id");

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", expectedKey.toUrlSafe())
      .build();

    FullEntity<?> outputEntity = transformer.transformStructuredRecord(inputRecord);

    Assert.assertEquals("string_value", outputEntity.getString("string_field"));
    Assert.assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformDifferentType() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.AUTO_GENERATED_KEY);
    Mockito.when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);
    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("field", Schema.of(Schema.Type.LONG)));

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("field", "string_value")
      .build();

    thrown.expect(ClassCastException.class);
    thrown.expectMessage("java.lang.String cannot be cast to java.lang.Number");

    transformer.transformStructuredRecord(inputRecord);
  }

  @Test
  public void testTransformNullableKeyField() {
    Mockito.when(config.shouldUseAutoGeneratedKey()).thenCallRealMethod();
    Mockito.when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    Mockito.when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    Mockito.when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    Mockito.when(config.getKeyType()).thenReturn(SinkKeyType.CUSTOM_NAME);
    Mockito.when(config.getKeyAlias()).thenReturn("test_key_alias");
    Schema schema = Schema.recordOf("schema",
      Schema.Field.of("test_key_alias", Schema.nullableOf(Schema.of(Schema.Type.STRING))));

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("test_key_alias", null)
      .build();

    thrown.expect(IllegalStateException.class);

    transformer.transformStructuredRecord(inputRecord);
  }

}
