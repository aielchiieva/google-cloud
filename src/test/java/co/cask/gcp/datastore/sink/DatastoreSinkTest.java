/*
 * Copyright Â© 2019 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package co.cask.gcp.datastore.sink;

import co.cask.cdap.api.data.format.StructuredRecord;
import co.cask.cdap.api.data.schema.Schema;
import co.cask.cdap.api.dataset.lib.KeyValue;
import co.cask.cdap.etl.api.Emitter;
import co.cask.gcp.datastore.sink.util.IndexStrategy;
import co.cask.gcp.datastore.sink.util.SinkKeyType;
import com.google.cloud.Timestamp;
import com.google.cloud.datastore.FullEntity;
import com.google.cloud.datastore.IncompleteKey;
import com.google.cloud.datastore.Key;
import com.google.cloud.datastore.KeyFactory;
import com.google.cloud.datastore.PathElement;
import org.apache.hadoop.io.NullWritable;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

import java.time.ZonedDateTime;
import java.util.Collections;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link DatastoreSink} class.
 */
@RunWith(MockitoJUnitRunner.class)
public class DatastoreSinkTest {

  @Rule
  public ExpectedException thrown = ExpectedException.none();

  @InjectMocks
  private DatastoreSink datastoreSink;

  @Mock
  private DatastoreSinkConfig config;

  @Mock
  private Emitter<KeyValue<NullWritable, FullEntity<?>>> emitter;


  @SuppressWarnings("ConstantConditions")
  @Test
  public void testTransformAllTypesIndexStrategyAll() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);
    when(config.getAncestor()).thenReturn(Collections.emptyList());
    when(config.getKeyType()).thenReturn(SinkKeyType.AUTO_GENERATED_KEY);

    Schema schema = Schema.recordOf("schema",
      Schema.Field.of("string_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("long_field", Schema.nullableOf(Schema.of(Schema.Type.LONG))),
      Schema.Field.of("int_field", Schema.nullableOf(Schema.of(Schema.Type.INT))),
      Schema.Field.of("double_field", Schema.nullableOf(Schema.of(Schema.Type.DOUBLE))),
      Schema.Field.of("float_field", Schema.nullableOf(Schema.of(Schema.Type.FLOAT))),
      Schema.Field.of("boolean_field", Schema.nullableOf(Schema.of(Schema.Type.BOOLEAN))),
      Schema.Field.of("timestamp_field", Schema.nullableOf(Schema.of(Schema.LogicalType.TIMESTAMP_MICROS))),
      Schema.Field.of("blob_field", Schema.nullableOf(Schema.of(Schema.Type.BYTES))),
      Schema.Field.of("null_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("entity_field",
                      Schema.nullableOf(Schema.recordOf("entity_field",
                        Schema.Field.of("nested_string_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
                        Schema.Field.of("nested_long_field", Schema.nullableOf(Schema.of(Schema.Type.LONG)))
      )))
    );

    ZonedDateTime dateTime = ZonedDateTime.now();

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("long_field", 10L)
      .set("int_field", 15)
      .set("double_field", 10.5D)
      .set("float_field", 15.5F)
      .set("boolean_field", true)
      .setTimestamp("timestamp_field", dateTime)
      .set("blob_field", "test_blob".getBytes())
      .set("null_field", null)
      .set("entity_field", StructuredRecord.builder(schema.getField("entity_field").getSchema().getNonNullable())
        .set("nested_string_field", "nested_value")
        .set("nested_long_field", 20L)
        .build())
      .build();


    //noinspection unchecked
    ArgumentCaptor<KeyValue<NullWritable, FullEntity<?>>> captor = ArgumentCaptor.forClass(KeyValue.class);

    datastoreSink.transform(inputRecord, emitter);

    verify(emitter).emit(captor.capture());

    KeyValue<NullWritable, FullEntity<?>> keyValue = captor.getValue();

    FullEntity<?> outputEntity = keyValue.getValue();
    assertEquals("string_value", outputEntity.getString("string_field"));
    assertFalse(outputEntity.getValue("string_field").excludeFromIndexes());

    assertEquals(10L, outputEntity.getLong("long_field"));
    assertFalse(outputEntity.getValue("long_field").excludeFromIndexes());

    assertEquals(15, outputEntity.getLong("int_field"));
    assertFalse(outputEntity.getValue("int_field").excludeFromIndexes());

    assertEquals(10.5D, outputEntity.getDouble("double_field"), 0);
    assertFalse(outputEntity.getValue("double_field").excludeFromIndexes());

    assertEquals(15.5, outputEntity.getDouble("float_field"), 0);
    assertFalse(outputEntity.getValue("float_field").excludeFromIndexes());

    assertEquals(Timestamp.ofTimeSecondsAndNanos(dateTime.toEpochSecond(), dateTime.getNano()),
                 outputEntity.getTimestamp("timestamp_field"));
    assertFalse(outputEntity.getValue("timestamp_field").excludeFromIndexes());

    assertTrue(outputEntity.getBoolean("boolean_field"));
    assertFalse(outputEntity.getValue("boolean_field").excludeFromIndexes());

    assertEquals("test_blob", new String(outputEntity.getBlob("blob_field").toByteArray()));
    assertFalse(outputEntity.getValue("blob_field").excludeFromIndexes());

    assertNull(outputEntity.getString("null_field"));
    assertFalse(outputEntity.getValue("null_field").excludeFromIndexes());

    FullEntity<IncompleteKey> nestedEntity = outputEntity.getEntity("entity_field");
    assertFalse(outputEntity.getValue("entity_field").excludeFromIndexes());

    assertEquals("nested_value", nestedEntity.getString("nested_string_field"));
    assertFalse(nestedEntity.getValue("nested_string_field").excludeFromIndexes());

    assertEquals(20L, nestedEntity.getLong("nested_long_field"));
    assertFalse(nestedEntity.getValue("nested_long_field").excludeFromIndexes());
  }

  @SuppressWarnings("ConstantConditions")
  @Test
  public void testTransformAllTypesIndexStrategyNone() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.NONE);
    when(config.getAncestor()).thenReturn(Collections.emptyList());
    when(config.getKeyType()).thenReturn(SinkKeyType.AUTO_GENERATED_KEY);

    Schema schema = Schema.recordOf("schema",
      Schema.Field.of("string_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("long_field", Schema.nullableOf(Schema.of(Schema.Type.LONG))),
      Schema.Field.of("int_field", Schema.nullableOf(Schema.of(Schema.Type.INT))),
      Schema.Field.of("double_field", Schema.nullableOf(Schema.of(Schema.Type.DOUBLE))),
      Schema.Field.of("float_field", Schema.nullableOf(Schema.of(Schema.Type.FLOAT))),
      Schema.Field.of("boolean_field", Schema.nullableOf(Schema.of(Schema.Type.BOOLEAN))),
      Schema.Field.of("timestamp_field", Schema.nullableOf(Schema.of(Schema.LogicalType.TIMESTAMP_MICROS))),
      Schema.Field.of("blob_field", Schema.nullableOf(Schema.of(Schema.Type.BYTES))),
      Schema.Field.of("null_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
      Schema.Field.of("entity_field",
                      Schema.nullableOf(Schema.recordOf("entity_field",
                        Schema.Field.of("nested_string_field", Schema.nullableOf(Schema.of(Schema.Type.STRING))),
                        Schema.Field.of("nested_long_field", Schema.nullableOf(Schema.of(Schema.Type.LONG)))
      )))
    );

    ZonedDateTime dateTime = ZonedDateTime.now();

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("long_field", 10L)
      .set("int_field", 15)
      .set("double_field", 10.5D)
      .set("float_field", 15.5F)
      .set("boolean_field", true)
      .setTimestamp("timestamp_field", dateTime)
      .set("blob_field", "test_blob".getBytes())
      .set("null_field", null)
      .set("entity_field", StructuredRecord.builder(schema.getField("entity_field").getSchema().getNonNullable())
        .set("nested_string_field", "nested_value")
        .set("nested_long_field", 20L)
        .build())
      .build();


    //noinspection unchecked
    ArgumentCaptor<KeyValue<NullWritable, FullEntity<?>>> captor = ArgumentCaptor.forClass(KeyValue.class);

    datastoreSink.transform(inputRecord, emitter);

    verify(emitter).emit(captor.capture());

    KeyValue<NullWritable, FullEntity<?>> keyValue = captor.getValue();

    FullEntity<?> outputEntity = keyValue.getValue();
    assertEquals("string_value", outputEntity.getString("string_field"));
    assertTrue(outputEntity.getValue("string_field").excludeFromIndexes());

    assertEquals(10L, outputEntity.getLong("long_field"));
    assertTrue(outputEntity.getValue("long_field").excludeFromIndexes());

    assertEquals(15, outputEntity.getLong("int_field"));
    assertTrue(outputEntity.getValue("int_field").excludeFromIndexes());

    assertEquals(10.5D, outputEntity.getDouble("double_field"), 0);
    assertTrue(outputEntity.getValue("double_field").excludeFromIndexes());

    assertEquals(15.5, outputEntity.getDouble("float_field"), 0);
    assertTrue(outputEntity.getValue("float_field").excludeFromIndexes());

    assertEquals(Timestamp.ofTimeSecondsAndNanos(dateTime.toEpochSecond(), dateTime.getNano()),
                 outputEntity.getTimestamp("timestamp_field"));
    assertTrue(outputEntity.getValue("timestamp_field").excludeFromIndexes());

    assertTrue(outputEntity.getBoolean("boolean_field"));
    assertTrue(outputEntity.getValue("boolean_field").excludeFromIndexes());

    assertEquals("test_blob", new String(outputEntity.getBlob("blob_field").toByteArray()));
    assertTrue(outputEntity.getValue("blob_field").excludeFromIndexes());

    assertNull(outputEntity.getString("null_field"));
    assertTrue(outputEntity.getValue("null_field").excludeFromIndexes());

    FullEntity<IncompleteKey> nestedEntity = outputEntity.getEntity("entity_field");
    assertTrue(outputEntity.getValue("entity_field").excludeFromIndexes());

    assertEquals("nested_value", nestedEntity.getString("nested_string_field"));
    assertTrue(nestedEntity.getValue("nested_string_field").excludeFromIndexes());

    assertEquals(20L, nestedEntity.getLong("nested_long_field"));
    assertTrue(nestedEntity.getValue("nested_long_field").excludeFromIndexes());
  }

  @Test
  public void testTransformIndexStrategyCustom() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.CUSTOM);
    when(config.getIndexedProperties()).thenReturn(Collections.singleton("string_field"));
    when(config.getAncestor()).thenReturn(Collections.emptyList());
    when(config.getKeyType()).thenReturn(SinkKeyType.AUTO_GENERATED_KEY);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("long_field", Schema.of(Schema.Type.LONG))

    );

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("long_field", 200L)
      .build();
    //noinspection unchecked
    ArgumentCaptor<KeyValue<NullWritable, FullEntity<?>>> captor = ArgumentCaptor.forClass(KeyValue.class);

    datastoreSink.transform(inputRecord, emitter);

    verify(emitter).emit(captor.capture());

    KeyValue<NullWritable, FullEntity<?>> keyValue = captor.getValue();
    FullEntity<?> outputEntity = keyValue.getValue();

    assertEquals("string_value", outputEntity.getString("string_field"));
    assertFalse(outputEntity.getValue("string_field").excludeFromIndexes());

    assertEquals(200L, outputEntity.getLong("long_field"));
    assertTrue(outputEntity.getValue("long_field").excludeFromIndexes());
  }

  @Test
  public void testTransformWithCustomStringKey() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getAncestor()).thenReturn(Collections.emptyList());
    when(config.getKeyType()).thenReturn(SinkKeyType.CUSTOM_NAME);
    when(config.getKeyAlias()).thenReturn("test_key_alias");
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.STRING))

    );

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", "custom_string_key_value")
      .build();
    //noinspection unchecked
    ArgumentCaptor<KeyValue<NullWritable, FullEntity<?>>> captor = ArgumentCaptor.forClass(KeyValue.class);

    datastoreSink.transform(inputRecord, emitter);

    verify(emitter).emit(captor.capture());

    KeyValue<NullWritable, FullEntity<?>> keyValue = captor.getValue();
    FullEntity<?> outputEntity = keyValue.getValue();

    assertEquals("string_value", outputEntity.getString("string_field"));

    Key expectedKey = Key.newBuilder(DatastoreSinkConfigHelper.TEST_PROJECT,
                                     DatastoreSinkConfigHelper.TEST_KIND,
                                     "custom_string_key_value")
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .build();
    assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformWithCustomLongKey() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getAncestor()).thenReturn(Collections.emptyList());
    when(config.getKeyType()).thenReturn(SinkKeyType.CUSTOM_NAME);
    when(config.getKeyAlias()).thenReturn("test_key_alias");
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.LONG))

    );

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", 380L)
      .build();
    //noinspection unchecked
    ArgumentCaptor<KeyValue<NullWritable, FullEntity<?>>> captor = ArgumentCaptor.forClass(KeyValue.class);

    datastoreSink.transform(inputRecord, emitter);

    verify(emitter).emit(captor.capture());

    KeyValue<NullWritable, FullEntity<?>> keyValue = captor.getValue();
    FullEntity<?> outputEntity = keyValue.getValue();

    assertEquals("string_value", outputEntity.getString("string_field"));

    Key expectedKey = Key.newBuilder(DatastoreSinkConfigHelper.TEST_PROJECT,
                                     DatastoreSinkConfigHelper.TEST_KIND,
                                     380L)
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .build();
    assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformWithCustomLongKeyWithAncestor() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getAncestor()).thenReturn(Collections.singletonList(PathElement.of("A", 100)));
    when(config.getKeyType()).thenReturn(SinkKeyType.CUSTOM_NAME);
    when(config.getKeyAlias()).thenReturn("test_key_alias");
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.LONG))

    );

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", 380L)
      .build();
    //noinspection unchecked
    ArgumentCaptor<KeyValue<NullWritable, FullEntity<?>>> captor = ArgumentCaptor.forClass(KeyValue.class);

    datastoreSink.transform(inputRecord, emitter);

    verify(emitter).emit(captor.capture());

    KeyValue<NullWritable, FullEntity<?>> keyValue = captor.getValue();
    FullEntity<?> outputEntity = keyValue.getValue();

    assertEquals("string_value", outputEntity.getString("string_field"));

    Key expectedKey = new KeyFactory(DatastoreSinkConfigHelper.TEST_PROJECT)
      .setKind(DatastoreSinkConfigHelper.TEST_KIND)
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .addAncestor(PathElement.of("A", 100))
      .newKey(380L);
    assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformWithKeyLiteral() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getKeyType()).thenReturn(SinkKeyType.KEY_LITERAL);
    when(config.getKeyAlias()).thenReturn("test_key_alias");
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.STRING))

    );

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", String.format("key(A, 100, %s, 'test_string_id')", DatastoreSinkConfigHelper.TEST_KIND))
      .build();
    //noinspection unchecked
    ArgumentCaptor<KeyValue<NullWritable, FullEntity<?>>> captor = ArgumentCaptor.forClass(KeyValue.class);

    datastoreSink.transform(inputRecord, emitter);

    verify(emitter).emit(captor.capture());

    KeyValue<NullWritable, FullEntity<?>> keyValue = captor.getValue();
    FullEntity<?> outputEntity = keyValue.getValue();

    assertEquals("string_value", outputEntity.getString("string_field"));

    Key expectedKey = new KeyFactory(DatastoreSinkConfigHelper.TEST_PROJECT)
      .setKind(DatastoreSinkConfigHelper.TEST_KIND)
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .addAncestor(PathElement.of("A", 100))
      .newKey("test_string_id");
    assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformWithUrlSafeKey() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getKeyType()).thenReturn(SinkKeyType.URL_SAFE_KEY);
    when(config.getKeyAlias()).thenReturn("test_key_alias");
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);

    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("string_field", Schema.of(Schema.Type.STRING)),
                                    Schema.Field.of("test_key_alias", Schema.of(Schema.Type.STRING))

    );

    Key expectedKey = new KeyFactory(DatastoreSinkConfigHelper.TEST_PROJECT)
      .setKind(DatastoreSinkConfigHelper.TEST_KIND)
      .setNamespace(DatastoreSinkConfigHelper.TEST_NAMESPACE)
      .addAncestor(PathElement.of("A", 100))
      .newKey("test_string_id");

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("string_field", "string_value")
      .set("test_key_alias", expectedKey.toUrlSafe())
      .build();
    //noinspection unchecked
    ArgumentCaptor<KeyValue<NullWritable, FullEntity<?>>> captor = ArgumentCaptor.forClass(KeyValue.class);

    datastoreSink.transform(inputRecord, emitter);

    verify(emitter).emit(captor.capture());

    KeyValue<NullWritable, FullEntity<?>> keyValue = captor.getValue();
    FullEntity<?> outputEntity = keyValue.getValue();

    assertEquals("string_value", outputEntity.getString("string_field"));
    assertEquals(expectedKey, outputEntity.getKey());
  }

  @Test
  public void testTransformDifferentType() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getKeyType()).thenReturn(SinkKeyType.AUTO_GENERATED_KEY);
    when(config.getIndexStrategy()).thenReturn(IndexStrategy.ALL);
    Schema schema = Schema.recordOf("schema",
                                    Schema.Field.of("field", Schema.of(Schema.Type.LONG))
    );

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("field", "string_value")
      .build();

    thrown.expect(ClassCastException.class);
    thrown.expectMessage("java.lang.String cannot be cast to java.lang.Number");

    datastoreSink.transform(inputRecord, emitter);
  }

  @Test
  public void testTransformNullableKeyField() {
    when(config.isUseAutoGeneratedKey()).thenCallRealMethod();
    when(config.getProject()).thenReturn(DatastoreSinkConfigHelper.TEST_PROJECT);
    when(config.getNamespace()).thenReturn(DatastoreSinkConfigHelper.TEST_NAMESPACE);
    when(config.getKind()).thenReturn(DatastoreSinkConfigHelper.TEST_KIND);
    when(config.getKeyType()).thenReturn(SinkKeyType.CUSTOM_NAME);
    when(config.getKeyAlias()).thenReturn("test_key_alias");
    Schema schema = Schema.recordOf("schema",
      Schema.Field.of("test_key_alias", Schema.nullableOf(Schema.of(Schema.Type.STRING)))
    );

    StructuredRecord inputRecord = StructuredRecord.builder(schema)
      .set("test_key_alias", null)
      .build();

    thrown.expect(IllegalArgumentException.class);
    thrown.expectMessage("Key field [test_key_alias] record type [nullable STRING] is not supported by "
                           + "key type: [Custom name]");

    datastoreSink.transform(inputRecord, emitter);
  }

}
