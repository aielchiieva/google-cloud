/*
 * Copyright Â© 2019 Cask Data, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package co.cask.gcp.datastore.sink;

import co.cask.cdap.api.annotation.Description;
import co.cask.cdap.api.annotation.Macro;
import co.cask.cdap.api.annotation.Name;
import co.cask.cdap.api.data.schema.Schema;
import co.cask.gcp.common.GCPReferenceSinkConfig;
import co.cask.gcp.datastore.sink.util.DatastoreSinkSchemaUtil;
import co.cask.gcp.datastore.sink.util.IndexStrategy;
import co.cask.gcp.datastore.sink.util.SinkKeyType;
import co.cask.gcp.datastore.util.DatastorePropertyUtil;
import co.cask.gcp.datastore.util.DatastoreUtil;
import com.google.cloud.datastore.PathElement;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;

import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;

import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.MAX_BATCH_SIZE;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_ANCESTOR;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_BATCH_SIZE;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_INDEXED_PROPERTIES;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_INDEX_STRATEGY;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_KEY_ALIAS;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_KEY_TYPE;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_KIND;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_NAMESPACE;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_PROJECT;
import static co.cask.gcp.datastore.sink.util.DatastoreSinkConstants.PROPERTY_SERVICE_FILE_PATH;

/**
 * This class {@link DatastoreSinkConfig} provides all the configuration required for
 * configuring the {@link DatastoreSink} plugin.
 */
public class DatastoreSinkConfig extends GCPReferenceSinkConfig {

  @Name(PROPERTY_NAMESPACE)
  @Macro
  @Nullable
  @Description("A namespace partitions entities into a subset of datastore. "
    + "If not provided, [default] namespace will be used. "
    + "(Macro Enabled)")
  private String namespace;

  @Name(PROPERTY_KIND)
  @Macro
  @Description("The kind of an entity categorizes it for the purpose of Datastore queries. "
    + "Equivalent to relational database table notion. "
    + "(Macro Enabled)")
  private String kind;

  @Name(PROPERTY_KEY_TYPE)
  @Macro
  @Description("Key is unique identifier assigned to the entity when it is created. Property defines what type of key "
    + "will be added to the entity, commonly is needed to perform upserts to the Cloud Datastore. "
    + "Can be one of four options: `Auto-generated key` - key will be generated by Datastore, `Custom name` - key "
    + "will be provided by the user, `Key literal` - key will be provided in Datastore key literal format including "
    + "complete path with ancestors, `URL-safe key` - key will be provided in encoded form that can be used "
    + "as part of a URL. "
    + "Note, if `Key literal`, `URL-safe key`, `Custom name` is selected, default key name (`__key__`) or its alias "
    + "must be present in the schema. `Key literal`, `URL-safe key` type must be of non-nullable STRING, "
    + "`Custom name` can be non-nullable STRING, INT or LONG. "
    + "(Macro Enabled)")
  private String keyType;

  @Name(PROPERTY_KEY_ALIAS)
  @Macro
  @Nullable
  @Description("Allows to set user-friendly name for the key column which default name is `__key__`. "
    + "Only applicable, if `Key Type` is set to `Custom name`, `Key literal` or `URL-safe key`. "
    + "If `Key Type` is set to `Auto-generated key`, property must be empty. "
    + "(Macro Enabled)")
  private String keyAlias;

  @Name(PROPERTY_ANCESTOR)
  @Macro
  @Nullable
  @Description("Ancestor identifies the common root entity in which the entities are grouped. "
    + "Must be indicated in key literal format: key(<kind>, <identifier>, <kind>, <identifier>, [...]). "
    + "Example: `key(kind_1, 'stringId', kind_2, 100)` "
    + "(Macro Enabled)")
  private String ancestor;

  @Name(PROPERTY_INDEX_STRATEGY)
  @Macro
  @Description("Index strategy defines which fields defined in schema will be indexed in Cloud Datastore. "
    + "Can be one of three options: `All` - all fields will be indexed, `None` - none of fields will be "
    + "indexed, `Custom` - indexed fields will be provided in `Indexed Properties`. "
    + "(Macro Enabled)")
  private String indexStrategy;

  @Name(PROPERTY_INDEXED_PROPERTIES)
  @Macro
  @Nullable
  @Description("List of property names to be marked as indexed, separated by comma. "
    + "Must be provided if `Index Strategy` is set to `Custom`, otherwise must be empty. "
    + "(Macro Enabled)")
  private String indexedProperties;

  @Name(PROPERTY_BATCH_SIZE)
  @Macro
  @Description("Maximum number of entities that can be passed in one batch to a Commit operation. "
    + "Allowed min size: `1`, max size: `500`. "
    + "(Macro Enabled)")
  private int batchSize;

  public DatastoreSinkConfig() {
    // needed for initialization
  }

  @VisibleForTesting
  public DatastoreSinkConfig(String referenceName,
                             String project,
                             String serviceFilePath,
                             @Nullable String namespace,
                             String kind,
                             String keyType,
                             @Nullable String keyAlias,
                             @Nullable String ancestor,
                             String indexStrategy,
                             int batchSize,
                             @Nullable String indexedProperties
  ) {
    this.referenceName = referenceName;
    this.project = project;
    this.serviceFilePath = serviceFilePath;
    this.namespace = namespace;
    this.kind = kind;
    this.indexStrategy = indexStrategy;
    this.indexedProperties = indexedProperties;
    this.keyType = keyType;
    this.keyAlias = keyAlias;
    this.ancestor = ancestor;
    this.batchSize = batchSize;
  }

  public String getNamespace() {
    return DatastorePropertyUtil.getNamespace(namespace);
  }

  public String getKind() {
    return kind;
  }

  public SinkKeyType getKeyType() {
    return SinkKeyType.fromValue(keyType)
      .orElseThrow(() -> new IllegalArgumentException("Unsupported key type value: " + keyType));
  }

  public String getKeyAlias() {
    return DatastorePropertyUtil.getKeyAlias(keyAlias);
  }

  public List<PathElement> getAncestor() {
    return DatastorePropertyUtil.parseKeyLiteral(ancestor);
  }

  public IndexStrategy getIndexStrategy() {
    return IndexStrategy.fromValue(indexStrategy)
      .orElseThrow(() -> new IllegalArgumentException("Unsupported index strategy value: " + indexStrategy));
  }

  public Set<String> getIndexedProperties() {
    if (Strings.isNullOrEmpty(indexedProperties)) {
      return Collections.emptySet();
    }
    return Stream.of(indexedProperties.split(","))
      .map(String::trim)
      .filter(name -> !name.isEmpty())
      .collect(Collectors.toSet());
  }

  public int getBatchSize() {
    return batchSize;
  }

  public boolean isUseAutoGeneratedKey() {
    return getKeyType() == SinkKeyType.AUTO_GENERATED_KEY;
  }

  public void validate(Schema schema) {
    super.validate();
    validateKind();
    DatastoreSinkSchemaUtil.validateSchema(schema);
    validateKeyType(schema);
    validateKeyAlias(schema);
    validateAncestors();
    validateIndexStrategy(schema);
    validateBatchSize();
    validateDatastoreConnection();
  }

  private void validateIndexStrategy(Schema schema) {
    if (containsMacro(indexStrategy)) {
      return;
    }

    if (getIndexStrategy() == IndexStrategy.CUSTOM) {
      validateIndexedProperties(schema);
    }
  }

  @VisibleForTesting
  void validateDatastoreConnection() {
    if (containsMacro(PROPERTY_SERVICE_FILE_PATH) || containsMacro(PROPERTY_PROJECT)) {
      return;
    }
    DatastoreUtil.getDatastore(getServiceAccountFilePath(), getProject());
  }

  private void validateKind() {
    if (containsMacro(PROPERTY_KIND)) {
      return;
    }
    DatastorePropertyUtil.validateKind(kind);
  }

  private void validateKeyType(Schema schema) {
    if (containsMacro(PROPERTY_KEY_TYPE)) {
      return;
    }
    if (!isUseAutoGeneratedKey()) {
      DatastoreSinkSchemaUtil.validateKeyAliasSchema(schema, getKeyType(), getKeyAlias());
    }
  }

  private void validateKeyAlias(Schema schema) {
    if (containsMacro(PROPERTY_KEY_TYPE) || containsMacro(PROPERTY_KEY_ALIAS)) {
      return;
    }
    if (!Strings.isNullOrEmpty(keyAlias)) {
      if (isUseAutoGeneratedKey()) {
        throw new IllegalArgumentException(
          String.format("Key alias must be empty if key type is [%s]", getKeyType().getValue()));
      }
      DatastoreSinkSchemaUtil.validateKeyAliasSchema(schema, getKeyType(), getKeyAlias());
    }
  }

  private void validateIndexedProperties(Schema schema) {
    if (containsMacro(PROPERTY_INDEXED_PROPERTIES)) {
      return;
    }
    Set<String> indexedProperties = getIndexedProperties();
    if (indexedProperties.isEmpty()) {
      throw new IllegalArgumentException(
        String.format("Indexed properties can not be empty if index strategy is [%s]",
                      getIndexStrategy().getValue()));
    }
    List<String> missedProperties = indexedProperties.stream()
      .filter(name -> schema.getField(name) == null)
      .collect(Collectors.toList());

    if (!missedProperties.isEmpty()) {
      throw new IllegalArgumentException(
        String.format("Indexed properties should exist in schema. Missed properties: %s", missedProperties));
    }
  }

  private void validateAncestors() {
    if (containsMacro(PROPERTY_ANCESTOR)) {
      return;
    }
    getAncestor();
  }

  private void validateBatchSize() {
    if (containsMacro(PROPERTY_BATCH_SIZE)) {
      return;
    }
    if (batchSize < 1 || batchSize > MAX_BATCH_SIZE) {
      throw new IllegalArgumentException(
        String.format("Invalid Datastore batch size: [%d]. Minimum number of entries in one batch: [1], "
                        + "maximum: [%d]", batchSize, MAX_BATCH_SIZE));
    }
  }
}
